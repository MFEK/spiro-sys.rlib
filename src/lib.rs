/* automatically generated by rust-bindgen 0.55.1 */

#![allow(non_camel_case_types, non_snake_case)]

pub const SPIRO_CORNER: u8 = 118u8;
pub const SPIRO_G4: u8 = 111u8;
pub const SPIRO_G2: u8 = 99u8;
pub const SPIRO_LEFT: u8 = 91u8;
pub const SPIRO_RIGHT: u8 = 93u8;
pub const SPIRO_END: u8 = 122u8;
pub const SPIRO_OPEN_CONTOUR: u8 = 123u8;
pub const SPIRO_END_OPEN_CONTOUR: u8 = 125u8;
pub const SPIRO_ANCHOR: u8 = 97u8;
pub const SPIRO_HANDLE: u8 = 104u8;
pub const SPIRO_INCLUDE_LAST_KNOT: u32 = 256;
pub const SPIRO_RETRO_VER1: u32 = 1024;
pub const SPIRO_REVERSE_SRC: u32 = 2048;
pub const SPIRO_ARC_CUB_QUAD_CLR: u32 = 32767;
pub const SPIRO_ARC_CUB_QUAD_MASK: u32 = 28672;
pub const SPIRO_CUBIC_TO_BEZIER: u32 = 0;
pub const SPIRO_CUBIC_MIN_MAYBE: u32 = 4096;
pub const SPIRO_ARC_MAYBE: u32 = 8192;
pub const SPIRO_ARC_MIN_MAYBE: u32 = 12288;
pub const SPIRO_QUAD0_TO_BEZIER: u32 = 16384;
pub type bezctx = _bezctx;
extern "C" {
    pub fn bezctx_moveto(bc: *mut bezctx, x: f64, y: f64, is_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bezctx_lineto(bc: *mut bezctx, x: f64, y: f64);
}
extern "C" {
    pub fn bezctx_quadto(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64);
}
extern "C" {
    pub fn bezctx_curveto(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64);
}
extern "C" {
    pub fn bezctx_mark_knot(bc: *mut bezctx, knot_idx: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _bezctx {
    pub moveto: ::std::option::Option<
        unsafe extern "C" fn(bc: *mut bezctx, x: f64, y: f64, is_open: ::std::os::raw::c_int),
    >,
    pub lineto: ::std::option::Option<unsafe extern "C" fn(bc: *mut bezctx, x: f64, y: f64)>,
    pub quadto: ::std::option::Option<
        unsafe extern "C" fn(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64),
    >,
    pub curveto: ::std::option::Option<
        unsafe extern "C" fn(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64),
    >,
    pub mark_knot: ::std::option::Option<
        unsafe extern "C" fn(bc: *mut bezctx, knot_idx: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout__bezctx() {
    assert_eq!(
        ::std::mem::size_of::<_bezctx>(),
        40usize,
        concat!("Size of: ", stringify!(_bezctx))
    );
    assert_eq!(
        ::std::mem::align_of::<_bezctx>(),
        8usize,
        concat!("Alignment of ", stringify!(_bezctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bezctx>())).moveto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bezctx),
            "::",
            stringify!(moveto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bezctx>())).lineto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bezctx),
            "::",
            stringify!(lineto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bezctx>())).quadto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bezctx),
            "::",
            stringify!(quadto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bezctx>())).curveto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bezctx),
            "::",
            stringify!(curveto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bezctx>())).mark_knot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bezctx),
            "::",
            stringify!(mark_knot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct spiro_cp {
    pub x: f64,
    pub y: f64,
    pub ty: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_spiro_cp() {
    assert_eq!(
        ::std::mem::size_of::<spiro_cp>(),
        24usize,
        concat!("Size of: ", stringify!(spiro_cp))
    );
    assert_eq!(
        ::std::mem::align_of::<spiro_cp>(),
        8usize,
        concat!("Alignment of ", stringify!(spiro_cp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).ty as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(ty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct spiro_seg_s {
    pub x: f64,
    pub y: f64,
    pub ty: ::std::os::raw::c_char,
    pub bend_th: f64,
    pub ks: [f64; 4usize],
    pub seg_ch: f64,
    pub seg_th: f64,
    pub l: f64,
}
#[test]
fn bindgen_test_layout_spiro_seg_s() {
    assert_eq!(
        ::std::mem::size_of::<spiro_seg_s>(),
        88usize,
        concat!("Size of: ", stringify!(spiro_seg_s))
    );
    assert_eq!(
        ::std::mem::align_of::<spiro_seg_s>(),
        8usize,
        concat!("Alignment of ", stringify!(spiro_seg_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).ty as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(ty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).bend_th as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(bend_th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).ks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).seg_ch as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(seg_ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).seg_th as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(seg_th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).l as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(l)
        )
    );
}
pub type spiro_seg = spiro_seg_s;
extern "C" {
    pub fn run_spiro(src: *const spiro_cp, n: ::std::os::raw::c_int) -> *mut spiro_seg;
}
extern "C" {
    pub fn free_spiro(s: *mut spiro_seg);
}
extern "C" {
    pub fn spiro_to_bpath(s: *const spiro_seg, n: ::std::os::raw::c_int, bc: *mut bezctx);
}
extern "C" {
    pub fn get_knot_th(s: *const spiro_seg, i: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn run_spiro0(
        src: *const spiro_cp,
        dm: *mut f64,
        ncq: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut spiro_seg;
}
extern "C" {
    pub fn spiro_to_bpath0(
        src: *const spiro_cp,
        s: *const spiro_seg,
        dm: *mut f64,
        ncq: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        bc: *mut bezctx,
    );
}
extern "C" {
    pub fn spiroreverse(src: *mut spiro_cp, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LibSpiroVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier(spiros: *mut spiro_cp, bc: *mut bezctx);
}
extern "C" {
    pub fn SpiroCPsToBezier(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    );
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier0(spiros: *mut spiro_cp, bc: *mut bezctx)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SpiroCPsToBezier0(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier1(
        spiros: *mut spiro_cp,
        bc: *mut bezctx,
        done: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SpiroCPsToBezier1(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
        done: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier2(
        spiros: *mut spiro_cp,
        ncq: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SpiroCPsToBezier2(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        ncq: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
